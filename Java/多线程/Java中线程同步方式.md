#### 同步方法

使用 synchronized 关键字修饰方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。

**synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。**

#### 同步代码块

使用 synchronized 关键字修饰代码块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步

#### wait 与 notify

wait() :使一个线程处于等待状态，并且释放所持有的对象的lock。

sleep() :使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉 InterruptedException 异常。

notify() :唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。

notifyAll() :唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。

#### 使用特殊域变量(volatile)实现线程同步

- 可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。
- 原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。

#### 可重入锁实现线程同步

ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。

**注：关于Lock对象和synchronized关键字的选择：** 

1. 最好两个都不用，使用一种`java.util.concurrent`包提供的机制，能够帮助用户处理所有与锁相关的代码。
2. 如果 synchronized 关键字能满足用户的需求，就用 synchronized，因为它能简化代码
3. 如果需要更高级的功能，就用 ReentrantLock 类，此时要注意及时释放锁，否则会出现死锁，通常在 finally 代码释放锁 

#### 使用局部变量实现线程同步

使用 ThreadLocal 管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。

  **注：ThreadLocal与同步机制** 

1. ThreadLocal 与同步机制都是为了解决多线程中相同变量的访问冲突问题。
2. 前者采用以"空间换时间"的方法，后者采用以"时间换空间"的方式

#### 使用阻塞队列实现线程同步

前面几种同步方式都是在底层实现的线程同步，但是我们在实际开发当中，应当尽量远离底层结构。 使用javaSE5.0版本中新增的`java.util.concurrent`包将有助于简化开发。

主要是使用LinkedBlockingQueue<E>来实现线程的同步 LinkedBlockingQueue<E>是一个基于已连接节点的，范围任意的blocking queue。 队列是先进先出的顺序（FIFO），关于队列以后会详细讲解~LinkedBlockingQueue 类常用方法 LinkedBlockingQueue() : 创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue put(E e) : 在队尾添加一个元素，如果队列满则阻塞 size() : 返回队列中的元素个数 take() : 移除并返回队头元素，如果队列空则阻塞代码实例： 实现商家生产商品和买卖商品的同步

**注：BlockingQueue<E>定义了阻塞队列的常用方法，尤其是四种操作元素的方法，我们要多加注意，当队列满或空时：**

　　add()方法会抛出异常

　　offer()方法返回false

　　take()方法会阻塞

　　put()方法会阻塞

#### 使用原子变量实现线程同步

需要使用线程同步的根本原因在于对普通变量的操作不是原子的。

那么什么是原子操作呢？原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作即-这几种行为要么同时完成，要么都不完成。在java的**util.concurrent.atomic包中提供了创建了原子类型变量的工具类**，使用该类可以简化线程同步。其中**AtomicInteger** 表可以用原子方式更新int的值，可用在应用程序中(如以原子方式增加的计数器)，但不能用于替换Integer；可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。