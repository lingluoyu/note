### Java内存区域

线程私有：

- 程序计数器
- 虚拟机栈
- 本地方法栈

线程共享：

- 堆
- 方法区
- 直接内存（非运行时数据区）

#### 程序计数器
程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。

为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，此类内存区域为“线程私有”的内存。

此内存区域是唯一一个在Java虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

#### Java虚拟机栈
Java虚拟机栈也是线程私有的，生命周期与线程相同。

虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个**栈帧**用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

Java内存可以粗糙的分为堆内存（Heap）和栈内存（Stack)，其中的“栈”就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。

**局部变量表**存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是一个纸箱对象起始地址的引用指针，也可能是纸箱一个代表对象的句柄或其他榆次对象相关的位置）。

**Java虚拟机栈中会出现两种异常：StackOverflowError 和 OutOfMemoryError。**

- `StackOverflowError` ：若虚拟机栈不允许动态扩展，当线程请求的栈深度大于当前虚拟机栈的最大深度时，抛出 StackOverflowError 异常。
- `OutOfMemoryError`：若虚拟机允许动态扩展，且当线程请求栈时内存耗尽，无法动态扩展，抛出 OutOfMemoryError 异常。

#### 本地方法栈

本地方法栈与虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**在 HotSpot 虚拟机中两者合二为一。

本地方法在执行的同时，也会在本地方法栈创建一个**栈帧**用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。

#### Java堆

Java 堆是 Java 虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。**

Java 堆是垃圾收集器管理的主要区域，因此也被称做**“GC 堆”（Garbage Collected Heap）**。从内存回收的角度，由于现在收集器基本都采用分带收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点还有 Eden 空间、From Survivor 空间、To Survivor 空间等。进一步划分的目的是为了更好的回收内存，或更快地分配内存。

#### 方法区

方法区与 Java 堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java虚拟机规范吧方法区描述为堆的一个逻辑部分，单是它却又一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。

方法区也被称为永久代，本质上两者并不等价。

> 《Java虚拟机规范》只是规定了方法区的概念，并未规定如何实现。**方法区与永久代就像Java中接口和实现类的关系，永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。**

常用参数

JDK 1.8之前（永久代未被彻底移除）

```bash
#方法区（永久代）初始大小
-XX:PermSize=N 
#方法区（永久代）最大大小，超过此值将抛出 OutOfMemoryError 异常：java.lang.OutOfMemoryError:PermGen
-XX:MaxPermSize=N
```

JDK 1.8（永久代被彻底移除，由元空间取代，元空间使用直接内存）

```bash
#设置Metaspace的初始大小
-XX:MetaspaceSize=N
#设置Metaspace的最大大小
-XX:MaxMetaspaceSize=N
```

#### 运行时常量池

运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池，用于存放编译器生成的各种字面量和符号引用。

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法在申请到内存时会抛出 OutOfMemoryError 异常。

JDK1.7及之后版本的 JVM 已经将常量池从方法区中移了出来，在 Java 堆中开辟了一块区域存放运行时常量池。

#### 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，也可能导致 OutOfMemoryError 异常。

JDK1.4中新加入的 **NIO（New Input/Output）**类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteByffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆中来回复制数据**。

本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。